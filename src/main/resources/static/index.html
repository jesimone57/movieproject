<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Juliet Movie Project</title>
  <style>
    :root {
      --bg: #f7fafc;
      --card: #ffffff;
      --text: #2d3748;
      --muted: #718096;
      --primary: #4a90e2;
      --primary-dark: #347acc;
      --border: #e2e8f0;
      --chip: #edf2f7;
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color: var(--text);
      background: linear-gradient(180deg, #fbfdff 0%, var(--bg) 100%);
    }

    header {
      padding: 28px 20px 10px;
      text-align: center;
    }
    h1 {
      margin: 0 0 6px;
      font-size: 28px;
      letter-spacing: 0.3px;
    }
    .subtitle { color: var(--muted); font-size: 14px; }

    /* Match af.html width so Filters and Results align exactly */
    .container { max-width: 1710px; margin: 0 auto; padding: 16px; }

    .panel {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.04);
    }

    /* Removed resizable panels to allow full page flow without internal scrollbars */

    .grid {
      display: grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 12px;
      align-items: end;
    }

    label { display: block; font-size: 12px; color: var(--muted); margin-bottom: 6px; }

    input, select {
      width: 100%;
      padding: 10px 12px;
      font-size: 14px;
      color: var(--text);
      background: #fff;
      border: 1px solid var(--border);
      border-radius: 8px;
      outline: none;
      transition: box-shadow 0.15s ease, border-color 0.15s ease;
    }
    input:focus, select:focus { border-color: var(--primary); box-shadow: 0 0 0 3px rgba(74,144,226,0.15); }

    /* Value-highlight state for inputs when they contain a value */
    input.has-value {
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(74,144,226,0.15);
    }

    /* Compact field helpers */
    .compact-select {
      width: auto; /* shrink to fit content */
      display: inline-block;
      white-space: nowrap;
    }
    .small-input {
      width: 86px; /* ~fits 4 digits comfortably */
      display: inline-block;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 10px 14px;
      border: 1px solid var(--primary);
      background: var(--primary);
      color: white;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.15s ease, transform 0.05s ease;
      text-decoration: none;
      white-space: nowrap;
    }
    .btn.secondary { background: #fff; color: var(--primary); }
    .btn:hover { background: var(--primary-dark); }
    .btn.secondary:hover { background: #f5f9ff; }
    .btn:active { transform: translateY(1px); }
    .btn:disabled { opacity: 0.6; cursor: progress; }

    .actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
    }

    .results {
      margin-top: 18px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }

    /* Sticky filters/header like af.html */
    .sticky-filters {
      position: sticky;
      top: 0;
      z-index: 30;
      /* Ensure the bar visually covers the full width when stuck */
      background: var(--card);
    }
    /* White background mask across the filters area */
    .sticky-filters::after {
      content: '';
      position: absolute;
      inset: 0;            /* default: cover full panel box */
      background: var(--card);
      z-index: 0;
      pointer-events: none;
    }
    /* When the filters are stuck, pin the mask to the viewport and
       size/position it to exactly match the table viewport (table-wrap) */
    .sticky-filters.is-stuck::after {
      position: fixed;
      inset: auto; /* we'll set explicit box */
      top: 0;
      left: var(--mask-left, 0px);
      width: var(--mask-width, 100vw);
      height: var(--mask-height, 0px);
      background: var(--card);
    }
    /* Keep actual filters content above the background mask */
    .sticky-filters > * { position: relative; z-index: 1; }

    /* Allow horizontal scroll for wide tables but keep vertical on page for sticky sections */
    .table-wrap { position: relative; overflow-x: auto; overflow-y: visible; border: 1px solid var(--border); border-radius: 12px; background: var(--card); }
    /* Use separate border model to avoid Safari sticky bugs */
    table { border-collapse: separate; border-spacing: 0; width: 100%; min-width: 880px; }
    /* Tighten column spacing a bit for a denser look */
    th, td { padding: 8px 10px; border-bottom: 1px solid var(--border); text-align: left; font-size: 14px; }
    /* Disable native sticky thead, we'll use a JS-managed cloned header */
    thead { position: static; z-index: auto; visibility: hidden; pointer-events: none; }
    th { background: #f1f5f9; font-weight: 700; color: #334155; }
    /* External sticky header container */
    .sticky-head { position: absolute; top: 0; left: 0; right: 0; z-index: 20; background: #f1f5f9; border-bottom: 1px solid var(--border); overflow: hidden; }
    .sticky-head.is-fixed { position: fixed; }
    .sticky-head .row { display: grid; align-items: center; grid-auto-rows: minmax(0, auto); will-change: transform; }
    .sticky-head .cell { padding: 8px 10px; font-weight: 700; color: #334155; white-space: normal; font-size: 14px; }
    tbody tr:hover { background: #f9fbfd; }

    .row { display: contents; }
    /* Right-align numeric table cells for clean column alignment */
    .numcol { text-align: right; font-variant-numeric: tabular-nums; white-space: nowrap; }
    /* Allow wrapping in numeric column headers to tighten column width */
    th.numcol { white-space: normal; }
    /* Sortable header controls */
    .sortable { display: inline-flex; align-items: center; gap: 2px; }
    /* Stack sort arrows vertically to save horizontal space */
    .sort-controls {
      display: inline-flex;
      flex-direction: column;
      gap: 1px;           /* reduce vertical gap between arrows */
      align-items: center;
      margin-left: 2px;   /* keep arrows very close to label */
    }
    .sort-controls button {
      padding: 0 3px; line-height: 1; height: 14px; min-width: 16px;
      border: 1px solid transparent; border-radius: 4px; background: transparent; color: #64748b;
      cursor: pointer; font-size: 12px;
    }
    .sort-controls button:hover { background: #e2e8f0; color: #334155; }
    .sort-controls button.active { background: #dbeafe; border-color: #bfdbfe; color: #1d4ed8; font-weight: 700; }
    .kpi {
      display: inline-block;
      padding: 4px 10px;
      border-radius: 999px;
      background: var(--chip);
      font-size: 12px;
    }

    /* Revenue cell layout: ensure the ROI pill fits and hugs the right edge neatly */
    .roi-cell { display: flex; justify-content: flex-end; align-items: center; width: 100%; }
    /* ROI highlight box styles for Revenue column */
    .roi {
      display: inline-flex;
      align-items: center;
      /* Add right padding for breathing room; compensate with negative right margin to keep right edge alignment */
      padding: 4px 8px 4px 10px; /* top right bottom left */
      margin-right: -8px;        /* maintain alignment with Budget column */
      border-radius: 16px;       /* a bit rounder for a better fit */
      line-height: 1.4;
      white-space: nowrap;
      font-variant-numeric: tabular-nums; /* consistent digit widths */
      /* Use inset box-shadow as a border so it doesn't affect layout width */
      box-shadow: inset 0 0 0 2px transparent;
    }
    .roi-green { box-shadow: inset 0 0 0 3px #16a34a; background: rgba(22,163,74,0.10); }
    .roi-yellow { box-shadow: inset 0 0 0 3px #f59e0b; background: rgba(245,158,11,0.10); }
    .roi-red { box-shadow: inset 0 0 0 3px #dc2626; background: rgba(220,38,38,0.10); }

    /* Title column width (70% of previous 320px setting = ~224px) */
    /* Column order (current after removing # column):
       1:Title, 2:Year, 3:IMDb, 4:Critic, 5:Popcorn, 6:Director, 7:Actors,
       8:Genre, 9:Duration, 10:Oscars Nom., 11:Oscars Won, 12:Oscars Won Details,
       13:MPAA, 14:AFI, 15:Budget, 16:Revenue, 17:Studio
    */
    th:nth-child(1), td:nth-child(1) { min-width: 224px; }

    /* Make the Oscars Nominated column a little narrower */
    th:nth-child(10), td:nth-child(10) { width: 80px; }

    pre.json { background: #0b1020; color: #d6eaff; padding: 16px; border-radius: 12px; overflow: auto; font-size: 13px; }
    code.key { color: #8be9fd }
    code.str { color: #f1fa8c }
    code.num { color: #bd93f9 }
    code.bool { color: #50fa7b }
    code.null { color: #ff79c6 }

    .section-title { font-weight: 700; margin: 6px 2px 2px; font-size: 15px; color: #334155; }

    .note { color: var(--muted); font-size: 12px; }
    /* Results header row with title and KPI next to each other */
    .results-header {
      display: flex;
      align-items: baseline;
      justify-content: flex-start; /* keep KPI immediately to the right of "Results" */
      gap: 8px;
      flex-wrap: wrap;
      margin: 0 0 8px 0;
    }

    .footer { text-align: center; color: var(--muted); font-size: 12px; padding: 18px; }

    /* Custom tooltip for Title cell: larger, styled hover instead of native title */
    .has-tooltip { position: relative; }
    .has-tooltip[data-tip]:hover::after {
      content: attr(data-tip);
      position: absolute;
      left: 0;
      top: calc(100% + 6px);
      z-index: 20;
      background: rgba(15, 23, 42, 0.96);
      color: #f8fafc;
      padding: 10px 12px;
      border-radius: 10px;
      font-size: 15px; /* increased hover font size for title tooltip */
      line-height: 1.4;
      max-width: 520px;
      white-space: normal;
      box-shadow: 0 8px 24px rgba(0,0,0,0.18);
    }
    .has-tooltip[data-tip]:hover::before {
      content: '';
      position: absolute;
      left: 12px;
      top: 100%;
      border-width: 6px 6px 0 6px;
      border-style: solid;
      border-color: rgba(15, 23, 42, 0.96) transparent transparent transparent;
    }
  </style>
</head>
<body>
  <header>
    <h1>Juliet Movie Project</h1>
    <div class="subtitle">A lightweight UI to exercise the MovieController API</div>
  </header>

  <div class="container">
    <div class="panel sticky-filters">
      <div class="section-title">Filters</div>
      <div class="grid" id="filters" style="margin-top:8px">
        <div class="col" style="grid-column: span 3;">
          <label for="title">Title contains</label>
          <input id="title" type="text" placeholder="e.g. Star" />
        </div>
        <div class="col" style="grid-column: span 3;">
          <label for="genre">Genre(s) (comma-separated)</label>
          <input id="genre" type="text" placeholder="e.g. Action, Adventure" />
        </div>
        <div class="col" style="grid-column: span 3;">
          <label for="director">Director contains</label>
          <input id="director" type="text" placeholder="e.g. Hitchcock" />
        </div>
        <div class="col" style="grid-column: span 3;">
          <label for="actor">Actor(s) (comma-separated)</label>
          <input id="actor" type="text" placeholder="e.g. Gable, Hepburn" />
        </div>
        <div class="col" style="grid-column: span 3;">
          <label for="oscarsWonDetails">Oscars Won Details contains</label>
          <input id="oscarsWonDetails" type="text" placeholder="e.g. Best Picture" />
        </div>
        <!-- Min rating and years set to same width as other filter boxes -->
        <div class="col" style="grid-column: span 3;">
          <label for="minRating">Min IMDb rating</label>
          <input id="minRating" type="text" placeholder="7.5" />
        </div>
        <div class="col" style="grid-column: span 3;">
          <label for="yearStart">Year start</label>
          <input id="yearStart" type="number" inputmode="numeric" placeholder="1990" />
        </div>
        <div class="col" style="grid-column: span 3;">
          <label for="yearEnd">Year end</label>
          <input id="yearEnd" type="number" inputmode="numeric" placeholder="2020" />
        </div>
        <!-- Studio filter placed before Sort by -->
        <div class="col" style="grid-column: span 3;">
          <label for="studio">Studio contains</label>
          <input id="studio" type="text" placeholder="e.g. Paramount, MGM" />
        </div>
        <!-- Sort by defaults to title and matches width of other filters -->
        <div class="col" style="grid-column: span 3;">
          <label for="sort">Sort by</label>
          <select id="sort">
            <option value="title" selected>title</option>
            <option value="year">year</option>
            <option value="rating">rating</option>
          </select>
        </div>
      </div>

      <div class="actions">
        <button class="btn" id="btnSearch" title="Search">ðŸ”Ž Search</button>
        <button class="btn secondary" id="btnClear" title="Clear filters">âœ– Clear</button>
        <!-- Results tally pill (kept sticky, matches af.html) -->
        <span id="resultCount" class="kpi" style="display:none"></span>
        <!-- Quick switch to Actor Filmographies view -->
        <span style="align-self:center; color: var(--muted); font-size: 12px;">View</span>
        <a href="af.html" class="btn secondary" id="btnViewAF" title="Switch to Actor Filmographies">Actor Filmography</a>
      </div>
      
    </div>

    <div class="results">
      <div class="panel">
        <div id="results"></div>
      </div>
    </div>

    <div class="footer">Powered by http://localhost:8080/api/movies</div>
  </div>

  <script>
    const api = (path, params) => {
      const base = 'http://localhost:8080';
      const url = new URL(base + path);
      if (params) Object.entries(params).forEach(([k, v]) => {
        if (v !== undefined && v !== null && v !== '') url.searchParams.set(k, v);
      });
      return fetch(url, { headers: { 'Accept': 'application/json' } });
    };

    const el = id => document.getElementById(id);

    function showLoading(button, loading=true) {
      if (!button) return;
      if (loading) {
        button.dataset.label = button.textContent;
        button.textContent = 'Loadingâ€¦';
        button.disabled = true;
      } else {
        button.textContent = button.dataset.label || 'Done';
        button.disabled = false;
      }
    }

    function formatJSON(obj) {
      // Simple syntax highlighter for JSON
      const json = JSON.stringify(obj, null, 2)
        .replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')
        .replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, match => {
          let cls = 'num';
          if (/^"/.test(match)) {
            cls = /:$/.test(match) ? 'key' : 'str';
          } else if (/true|false/.test(match)) {
            cls = 'bool';
          } else if (/null/.test(match)) {
            cls = 'null';
          }
          return '<code class="' + cls + '">' + match + '</code>';
        });
      return `<pre class="json">${json}</pre>`;
    }

    // In-memory cache and sorting state for client-side sorting
    let lastResults = [];
    let currentSort = null; // { key: string, dir: 'asc'|'desc' }

    // ---- UI State Persistence (single-session; store only UI state) ----
    const MOVIES_STATE_KEY = 'ui.movies.state';

    function readMoviesState() {
      try {
        const raw = sessionStorage.getItem(MOVIES_STATE_KEY);
        return raw ? JSON.parse(raw) : null;
      } catch (_) { return null; }
    }
    function writeMoviesState(state) {
      try { sessionStorage.setItem(MOVIES_STATE_KEY, JSON.stringify(state)); } catch (_) {}
    }
    function clearMoviesState() {
      try { sessionStorage.removeItem(MOVIES_STATE_KEY); } catch (_) {}
    }
    function collectMovieFilters() {
      return {
        title: (el('title')?.value || '').trim(),
        sortDropdown: el('sort')?.value || 'title',
        genre: (el('genre')?.value || '').trim(),
        director: (el('director')?.value || '').trim(),
        actor: (el('actor')?.value || '').trim(),
        oscarsWonDetails: (el('oscarsWonDetails')?.value || '').trim(),
        studio: (el('studio')?.value || '').trim(),
        minRating: el('minRating')?.value || '',
        yearStart: el('yearStart')?.value || '',
        yearEnd: el('yearEnd')?.value || ''
      };
    }
    function collectMoviesState(extra={}) {
      const filters = collectMovieFilters();
      const colSort = currentSort ? { key: currentSort.key, dir: currentSort.dir } : null;
      const scrollY = window.scrollY || window.pageYOffset || 0;
      // try to capture horizontal scroll of results table
      const wrap = document.querySelector('.table-wrap');
      const scrollX = wrap ? wrap.scrollLeft : 0;
      return { filters, colSort, scrollY, scrollX, ...extra };
    }
    function saveMoviesState(extra={}) {
      writeMoviesState(collectMoviesState(extra));
    }

    // Parse strings like "98%" into numeric 98 for proper sorting
    function parsePercent(val) {
      if (val === null || val === undefined) return null;
      if (typeof val === 'number') return val;
      const s = String(val).trim();
      if (!s) return null;
      const n = parseFloat(s.replace('%', ''));
      return Number.isNaN(n) ? null : n;
    }

    function getSortValue(m, key) {
      switch (key) {
        case 'title': return (m.title ?? '').toString();
        case 'year': return (m.year ?? null);
        case 'imdb': return (m.imdbRating ?? null);
        case 'budget': return (m.budget_usd_millions ?? m.budget ?? null);
        case 'revenue': return (m.gross_revenue_usd_millions ?? m.revenue ?? null);
        case 'rt_critic': {
          const v = m.ratings && (m.ratings.rotten_tomatoes_critic ?? m.ratings.rottenTomatoesCritic);
          return parsePercent(v);
        }
        case 'rt_popcorn': {
          const v = m.ratings && (m.ratings.rotten_tomatoes_popcorn ?? m.ratings.rottenTomatoesPopcorn);
          return parsePercent(v);
        }
        case 'director': {
          const dname = m.director && (m.director.name ?? m.director?.Name);
          return (dname ?? '').toString();
        }
        case 'actors': {
          if (Array.isArray(m.actors)) {
            // Sort by a single comparable string of actor names
            return m.actors
              .map(a => (a && (a.name ?? a?.Name) ? String(a.name ?? a?.Name) : ''))
              .filter(Boolean)
              .join(', ');
          }
          return '';
        }
        case 'genre': {
          if (Array.isArray(m.genres)) return m.genres.join(', ').toString();
          return (m.genres ?? '').toString();
        }
        case 'duration': return (m.runtime_minutes ?? null);
        case 'osc_nom': return (m.oscars_nominated ?? null);
        case 'osc_won': return (m.oscars_won ?? null);
        case 'osc_won_details': {
          if (Array.isArray(m.oscars_won_details)) {
            return m.oscars_won_details.join(', ');
          }
          return '';
        }
        case 'mpaa': return (m.mpaa_rating ?? '').toString();
        case 'afi': return (m.afi_ranking ?? m.afiRanking ?? null);
        case 'studio': {
          const s = (m.production_studio ?? m.studio ?? '');
          return s ? String(s) : '';
        }
        default: return null;
      }
    }

    function compareValues(a, b) {
      // Handle null/undefined: push to end in ascending
      const na = (a === null || a === undefined || a === '');
      const nb = (b === null || b === undefined || b === '');
      if (na && nb) return 0;
      if (na) return 1;
      if (nb) return -1;
      const an = typeof a === 'number';
      const bn = typeof b === 'number';
      if (an && bn) return a - b;
      // Try to coerce numeric strings
      const ap = parseFloat(a);
      const bp = parseFloat(b);
      if (!Number.isNaN(ap) && !Number.isNaN(bp) && String(a).trim() !== '' && String(b).trim() !== '') {
        return ap - bp;
      }
      return String(a).localeCompare(String(b), undefined, { sensitivity: 'base' });
    }

    // Format numeric million values with consistent decimals for visual alignment
    function formatMillions(val) {
      if (val === null || val === undefined || val === '') return '';
      const n = Number(val);
      if (Number.isNaN(n)) return '';
      // Allow 0â€“2 decimals depending on data precision
      return n.toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 2 });
    }

    function sortData(data, key, dir) {
      const sorted = data.slice().sort((m1, m2) => {
        const v1 = getSortValue(m1, key);
        const v2 = getSortValue(m2, key);
        const base = compareValues(v1, v2);
        return dir === 'desc' ? -base : base;
      });
      return sorted;
    }

    function setActiveSortIndicators(root) {
      const buttons = root.querySelectorAll('button.sort');
      buttons.forEach(btn => {
        const key = btn.getAttribute('data-key');
        const dir = btn.getAttribute('data-dir');
        const isActive = currentSort && currentSort.key === key && currentSort.dir === dir;
        btn.classList.toggle('active', !!isActive);
      });
    }

    function wireSortHandlers(root) {
      const buttons = root.querySelectorAll('button.sort');
      buttons.forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          const key = btn.getAttribute('data-key');
          const dir = btn.getAttribute('data-dir');
          currentSort = { key, dir };
          if (Array.isArray(lastResults)) {
            const data = sortData(lastResults, key, dir);
            renderInto(el('results'), data);
          }
          // Persist updated column sort
          saveMoviesState();
        });
      });
    }

    // Determine ROI highlight class based on revenue vs budget
    function roiClass(budget, revenue) {
      if (budget == null || revenue == null || isNaN(budget) || isNaN(revenue) || budget <= 0) return '';
      const ratio = Number(revenue) / Number(budget);
      if (ratio >= 2) return 'roi roi-green';
      if (ratio >= 1) return 'roi roi-yellow';
      return 'roi roi-red';
    }

    function renderRevenueCell(m) {
      const rev = (m.gross_revenue_usd_millions ?? m.revenue ?? null);
      const bud = (m.budget_usd_millions ?? m.budget ?? null);
      if (rev == null || rev === '') return '';
      const cls = roiClass(bud, rev);
      const text = escapeHtml(formatMillions(rev));
      return cls ? `<span class="${cls}">${text}</span>` : text;
    }

    function renderMovies(movies) {
      if (!Array.isArray(movies)) return formatJSON(movies);
      const rows = movies.map(m => `
      <tr>
        <td class="has-tooltip" data-tip="${m.description ? escapeAttr(m.description) : ''}">${
          (m.imdb_url ? `<a href="${escapeAttr(m.imdb_url)}" target="_blank">${escapeHtml(m.title ?? '')}</a>` : escapeHtml(m.title ?? ''))
        }</td>
        <td>${m.year ?? ''}</td>
        <td><span class="kpi">${m.imdbRating ?? ''}</span></td>
        <td class="numcol">${(m.ratings && (m.ratings.rotten_tomatoes_critic ?? m.ratings.rottenTomatoesCritic)) || ''}</td>
        <td class="numcol">${(m.ratings && (m.ratings.rotten_tomatoes_popcorn ?? m.ratings.rottenTomatoesPopcorn)) || ''}</td>
        <td>${(m.director && m.director.name) ? (m.director.imdb_person_url ? `<a href="${escapeAttr(m.director.imdb_person_url)}" target="_blank">${escapeHtml(m.director.name)}</a>` : escapeHtml(m.director.name)) : ''}</td>
        <td>${Array.isArray(m.actors) ? m.actors.map(a => {
          const name = a && a.name ? escapeHtml(a.name) : '';
          const url = a && a.imdb_person_url ? escapeAttr(a.imdb_person_url) : null;
          return name ? (url ? `<a href="${url}" target="_blank">${name}</a>` : name) : '';
        }).filter(Boolean).join(', ') : ''}</td>
        <td>${Array.isArray(m.genres) ? m.genres.map(g => escapeHtml(g)).join(', ') : (m.genres ?? '')}</td>
        <td class="numcol">${m.runtime_minutes != null ? escapeHtml(m.runtime_minutes) + ' min' : ''}</td>
        <td class="numcol">${m.oscars_nominated ?? ''}</td>
        <td class="numcol">${m.oscars_won ?? ''}</td>
        <td>${Array.isArray(m.oscars_won_details) ? m.oscars_won_details.map(d => escapeHtml(d)).join('; ') : ''}</td>
        <td>${m.mpaa_rating ?? ''}</td>
        <td class="numcol">${m.afi_ranking ?? m.afiRanking ?? ''}</td>
        <td class="numcol">${formatMillions(m.budget_usd_millions ?? m.budget)}</td>
        <td class="numcol"><div class="roi-cell">${renderRevenueCell(m)}</div></td>
        <td>${escapeHtml(m.production_studio ?? m.studio ?? '')}</td>
      </tr>`).join('');
    return `
      <div class="table-wrap">
        <div id="stickyHead" class="sticky-head"></div>
        <table id="resultsTable">
          <thead>
            <tr>
              <th>
                <div class="sortable"><span>Title</span>
                  <span class="sort-controls">
                    <button class="sort" data-key="title" data-dir="asc" title="Sort ascending">â–²</button>
                    <button class="sort" data-key="title" data-dir="desc" title="Sort descending">â–¼</button>
                  </span>
                </div>
              </th>
              <th>
                <div class="sortable"><span>Year</span>
                  <span class="sort-controls">
                    <button class="sort" data-key="year" data-dir="asc" title="Sort ascending">â–²</button>
                    <button class="sort" data-key="year" data-dir="desc" title="Sort descending">â–¼</button>
                  </span>
                </div>
              </th>
              <th>
                <div class="sortable"><span>IMDb</span>
                  <span class="sort-controls">
                    <button class="sort" data-key="imdb" data-dir="asc" title="Sort ascending">â–²</button>
                    <button class="sort" data-key="imdb" data-dir="desc" title="Sort descending">â–¼</button>
                  </span>
                </div>
              </th>
              <th>
                <div class="sortable"><span>Critic</span>
                  <span class="sort-controls">
                    <button class="sort" data-key="rt_critic" data-dir="asc" title="Sort ascending">â–²</button>
                    <button class="sort" data-key="rt_critic" data-dir="desc" title="Sort descending">â–¼</button>
                  </span>
                </div>
              </th>
              <th>
                <div class="sortable"><span>Popcorn</span>
                  <span class="sort-controls">
                    <button class="sort" data-key="rt_popcorn" data-dir="asc" title="Sort ascending">â–²</button>
                    <button class="sort" data-key="rt_popcorn" data-dir="desc" title="Sort descending">â–¼</button>
                  </span>
                </div>
              </th>
              <th>
                <div class="sortable"><span>Director</span>
                  <span class="sort-controls">
                    <button class="sort" data-key="director" data-dir="asc" title="Sort ascending">â–²</button>
                    <button class="sort" data-key="director" data-dir="desc" title="Sort descending">â–¼</button>
                  </span>
                </div>
              </th>
              <th>
                <div class="sortable"><span>Actors</span>
                  <span class="sort-controls">
                    <button class="sort" data-key="actors" data-dir="asc" title="Sort ascending">â–²</button>
                    <button class="sort" data-key="actors" data-dir="desc" title="Sort descending">â–¼</button>
                  </span>
                </div>
              </th>
              <th>
                <div class="sortable"><span>Genre</span>
                  <span class="sort-controls">
                    <button class="sort" data-key="genre" data-dir="asc" title="Sort ascending">â–²</button>
                    <button class="sort" data-key="genre" data-dir="desc" title="Sort descending">â–¼</button>
                  </span>
                </div>
              </th>
              <th class="numcol">
                <div class="sortable"><span>Duration</span>
                  <span class="sort-controls">
                    <button class="sort" data-key="duration" data-dir="asc" title="Sort ascending">â–²</button>
                    <button class="sort" data-key="duration" data-dir="desc" title="Sort descending">â–¼</button>
                  </span>
                </div>
              </th>
              <th class="numcol">
                <div class="sortable"><span>Oscars Nom.</span>
                  <span class="sort-controls">
                    <button class="sort" data-key="osc_nom" data-dir="asc" title="Sort ascending">â–²</button>
                    <button class="sort" data-key="osc_nom" data-dir="desc" title="Sort descending">â–¼</button>
                  </span>
                </div>
              </th>
              <th class="numcol">
                <div class="sortable"><span>Oscars<br>Won</span>
                  <span class="sort-controls">
                    <button class="sort" data-key="osc_won" data-dir="asc" title="Sort ascending">â–²</button>
                    <button class="sort" data-key="osc_won" data-dir="desc" title="Sort descending">â–¼</button>
                  </span>
                </div>
              </th>
              <th>
                <div class="sortable"><span>Oscars Won Details</span>
                  <span class="sort-controls">
                    <button class="sort" data-key="osc_won_details" data-dir="asc" title="Sort ascending">â–²</button>
                    <button class="sort" data-key="osc_won_details" data-dir="desc" title="Sort descending">â–¼</button>
                  </span>
                </div>
              </th>
              <th>
                <div class="sortable"><span>MPAA</span>
                  <span class="sort-controls">
                    <button class="sort" data-key="mpaa" data-dir="asc" title="Sort ascending">â–²</button>
                    <button class="sort" data-key="mpaa" data-dir="desc" title="Sort descending">â–¼</button>
                  </span>
                </div>
              </th>
              <th class="numcol">
                <div class="sortable"><span>AFI</span>
                  <span class="sort-controls">
                    <button class="sort" data-key="afi" data-dir="asc" title="Sort ascending">â–²</button>
                    <button class="sort" data-key="afi" data-dir="desc" title="Sort descending">â–¼</button>
                  </span>
                </div>
              </th>
              <th class="numcol">
                <div class="sortable"><span>Budget</span>
                  <span class="sort-controls">
                    <button class="sort" data-key="budget" data-dir="asc" title="Sort ascending">â–²</button>
                    <button class="sort" data-key="budget" data-dir="desc" title="Sort descending">â–¼</button>
                  </span>
                </div>
              </th>
              <th class="numcol">
                <div class="sortable"><span>Revenue</span>
                  <span class="sort-controls">
                    <button class="sort" data-key="revenue" data-dir="asc" title="Sort ascending">â–²</button>
                    <button class="sort" data-key="revenue" data-dir="desc" title="Sort descending">â–¼</button>
                  </span>
                </div>
              </th>
              <th>
                <div class="sortable"><span>Studio</span>
                  <span class="sort-controls">
                    <button class="sort" data-key="studio" data-dir="asc" title="Sort ascending">â–²</button>
                    <button class="sort" data-key="studio" data-dir="desc" title="Sort descending">â–¼</button>
                  </span>
                </div>
              </th>
            </tr>
          </thead>
          <tbody>${rows}</tbody>
        </table>
      </div>`;
    }

    function renderInto(container, data) {
      // Render and then attach sort handlers + highlight active
      container.innerHTML = renderMovies(data);
      wireSortHandlers(container);
      setActiveSortIndicators(container);
      // Build/update sticky header to mirror the table header and stick below filters
      if (typeof updateStickyHeaderOffset === 'function') updateStickyHeaderOffset();
      // IMPORTANT: On index.html the table is injected dynamically, so bind sticky listeners AFTER render
      if (window.stickyApi) {
        try {
          if (!window.__stickyBound) {
            if (typeof window.stickyApi.bind === 'function') window.stickyApi.bind();
            window.__stickyBound = true;
          }
          if (typeof window.stickyApi.rebuild === 'function') window.stickyApi.rebuild();
          if (typeof window.stickyApi.updateMode === 'function') window.stickyApi.updateMode();
        } catch (_) { /* no-op */ }
      }
    }

    function escapeHtml(s) {
      return String(s)
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#039;');
    }
    function escapeAttr(s) { return escapeHtml(s); }

    function setKPIs(listCount, raw) {
      const k = el('kpis');
      // If KPI container is removed from the page, safely no-op
      if (!k) return;
      const parts = [];
      if (typeof listCount === 'number') parts.push(kpi(`${listCount} item${listCount!==1?'s':''}`));
      if (raw && typeof raw === 'object' && !Array.isArray(raw)) parts.push(kpi(`${Object.keys(raw).length} keys`));
      k.innerHTML = parts.join('');
    }
    function kpi(text) { return `<span class="kpi">${escapeHtml(text)}</span>`; }

    // Mirror af.html behavior: sticky results tally next to Clear button
    function setResultCount(n) {
      const rc = el('resultCount');
      if (!rc) return;
      if (typeof n === 'number') {
        rc.textContent = `${n} result${n === 1 ? '' : 's'}`;
        rc.style.display = 'inline-block';
      } else {
        rc.textContent = '';
        rc.style.display = 'none';
      }
    }

    async function handle(button, fn) {
      try { showLoading(button, true); await fn(); }
      catch (e) {
        el('results').innerHTML = `<div class="panel" style="border-color:#fecaca;background:#fff1f2;color:#7f1d1d">Error: ${escapeHtml(e.message || String(e))}</div>`;
        // Hide tally on errors to match af.html behavior
        setResultCount(null);
      }
      finally { showLoading(button, false); }
    }

    // Wire buttons
    el('btnSearch').addEventListener('click', () => handle(el('btnSearch'), async () => {
      const params = {
        title: el('title').value.trim(),
        // default sort is 'title' per requirement
        sort: el('sort').value || 'title',
        genre: el('genre').value.trim() || undefined,
        director: el('director').value.trim() || undefined,
        actor: el('actor').value.trim() || undefined,
        oscarWon: el('oscarsWonDetails').value.trim() || undefined,
        studio: el('studio').value.trim() || undefined,
        minRating: el('minRating').value ? Number(el('minRating').value) : undefined,
        yearStart: el('yearStart').value ? Number(el('yearStart').value) : undefined,
        yearEnd: el('yearEnd').value ? Number(el('yearEnd').value) : undefined,
      };
      const r = await api('/api/movies/search', params);
      const data = await r.json();
      if (Array.isArray(data)) {
        lastResults = data.slice();
        const toRender = currentSort ? sortData(lastResults, currentSort.key, currentSort.dir) : lastResults;
        renderInto(el('results'), toRender);
        setKPIs(toRender.length, data);
        setResultCount(toRender.length);
        // After rendering, reset scroll position so results start at the top
        scrollResultsToTop();
        // Persist state after successful search, include a marker to allow restore without filters
        saveMoviesState({ lastSearched: Date.now(), lastResultsLength: Array.isArray(toRender) ? toRender.length : null });
      } else {
        el('results').innerHTML = renderMovies(data);
        setKPIs(undefined, data);
        setResultCount(null);
        scrollResultsToTop();
        // Persist state after successful search of non-array payload as well
        saveMoviesState({ lastSearched: Date.now(), lastResultsLength: null });
      }
    }));


    // Optional: Load initial data
    // document.getElementById('btnAll').click();

    // Clear button: reset all inputs and reset the results view
    el('btnClear').addEventListener('click', () => {
      // Reset all filters
      el('title').value = '';
      el('director').value = '';
      el('actor').value = '';
      el('oscarsWonDetails').value = '';
      el('genre').value = '';
      el('studio').value = '';
      el('minRating').value = '';
      el('yearStart').value = '';
      el('yearEnd').value = '';
      // Revert the dropdown to default sort
      el('sort').value = 'title';

      // Clear any column sort settings and cached results
      currentSort = null;
      lastResults = [];

      // Clear the results view and KPI count entirely
      const resultsHost = el('results');
      if (resultsHost) resultsHost.innerHTML = '';
      const kpisHost = el('kpis');
      if (kpisHost) kpisHost.innerHTML = '';
      // Hide the sticky results tally
      setResultCount(null);

      // Also clear any existing cloned sticky header content if present
      const stickyHead = document.getElementById('stickyHead');
      if (stickyHead) stickyHead.innerHTML = '';

      // Refresh sticky offsets/mode and scroll the page so the header area is visible
      if (typeof updateStickyHeaderOffset === 'function') {
        try { updateStickyHeaderOffset(); } catch(_) {}
      }
      if (window.stickyApi && typeof window.stickyApi.updateMode === 'function') {
        try { window.stickyApi.updateMode(); } catch(_) {}
      }
      // Reset viewport position to the top of the results header area
      if (typeof scrollResultsToTop === 'function') {
        try { scrollResultsToTop(); } catch (_) {}
      }

      // update value-highlights and focus first input for convenience
      refreshValueHighlights();
      const first = el('title');
      if (first) first.focus();
      // Clear persisted UI state for Movies page
      clearMoviesState();
    });

    // Add blue outline when inputs contain values
    function applyValueHighlight(input) {
      if (!input) return;
      const hasValue = input.value != null && String(input.value).trim() !== '';
      input.classList.toggle('has-value', hasValue);
    }
    function refreshValueHighlights() {
      ['title','director','actor','oscarsWonDetails','genre','studio','minRating','yearStart','yearEnd'].forEach(id => applyValueHighlight(el(id)));
    }
    ['title','director','actor','oscarsWonDetails','genre','studio','minRating','yearStart','yearEnd'].forEach(id => {
      const node = el(id);
      node.addEventListener('input', () => applyValueHighlight(node));
      node.addEventListener('change', () => applyValueHighlight(node));
    });
    // initialize on load
    refreshValueHighlights();

    // Pressing Enter in any filter field triggers Search
    const filtersGrid = document.getElementById('filters');
    if (filtersGrid) {
      filtersGrid.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          const searchBtn = el('btnSearch');
          if (searchBtn && !searchBtn.disabled) {
            searchBtn.click();
          }
        }
      });
    }

    // --- Sticky filters + external sticky header (modeled after af.html) ---
    function updateStickyHeaderOffset() {
      const filters = document.querySelector('.sticky-filters');
      const wraps = document.querySelectorAll('.table-wrap');
      let offset = 0;
      let isStuck = false;
      let maskLeft = 0;
      let maskWidth = window.innerWidth;
      let maskHeight = 0;

      if (filters) {
        const rect = filters.getBoundingClientRect();
        isStuck = rect.top <= 0;
        if (isStuck) {
          offset = Math.max(0, Math.ceil(rect.height) - 1);
        }
        maskHeight = Math.max(0, Math.ceil(rect.height));
      }

      // Use the first results table-wrap as the viewport reference
      const wrap = document.querySelector('#results .table-wrap') || document.querySelector('.table-wrap');
      if (wrap && isStuck) {
        const wr = wrap.getBoundingClientRect();
        maskLeft = Math.round(wr.left);
        maskWidth = Math.round(wr.width);
      }

      // Apply offset for sticky header positioning
      wraps.forEach(w => w.style.setProperty('--filters-offset', offset + 'px'));

      // Toggle stuck class and update CSS variables for mask sizing
      if (filters) {
        filters.classList.toggle('is-stuck', isStuck);
        filters.style.setProperty('--mask-left', maskLeft + 'px');
        filters.style.setProperty('--mask-width', maskWidth + 'px');
        filters.style.setProperty('--mask-height', maskHeight + 'px');
      }
    }
    window.addEventListener('resize', updateStickyHeaderOffset);
    window.addEventListener('load', updateStickyHeaderOffset);
    window.addEventListener('scroll', updateStickyHeaderOffset, { passive: true });

    // Helpers for sorting from cloned header
    function applySortFromButton(btn) {
      const key = btn.getAttribute('data-key');
      const dir = btn.getAttribute('data-dir');
      currentSort = { key, dir };
      if (Array.isArray(lastResults)) {
        const data = sortData(lastResults, key, dir);
        renderInto(el('results'), data);
      }
    }

    window.stickyApi = (function() {
      const wrap = () => document.querySelector('#results .table-wrap') || document.querySelector('.table-wrap');
      const headHost = () => document.getElementById('stickyHead');
      const table = () => document.getElementById('resultsTable');
      const theadRow = () => document.querySelector('#resultsTable thead tr');
      const filters = () => document.querySelector('.sticky-filters');

      function rebuild() {
        const host = headHost();
        const tr = theadRow();
        if (!host || !tr) return;
        host.innerHTML = '';
        const row = document.createElement('div');
        row.className = 'row';
        const ths = Array.from(tr.children);
        ths.forEach((th) => {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.innerHTML = th.innerHTML;
          if (th.classList.contains('numcol')) cell.style.textAlign = 'right';
          row.appendChild(cell);
        });
        host.appendChild(row);
        // Wire sort buttons in cloned header
        host.querySelectorAll('button.sort').forEach(btn => {
          btn.addEventListener('click', (e) => { e.preventDefault(); applySortFromButton(btn); });
        });
        syncWidths();
        syncScroll();
        updateMode();
        // reflect active state
        setActiveSortIndicators(host);
      }

      function syncWidths() {
        const tr = theadRow();
        const host = headHost();
        if (!tr || !host) return;
        const ths = Array.from(tr.children);
        const widths = ths.map(th => Math.ceil(th.getBoundingClientRect().width));
        const row = host.firstElementChild;
        if (!row) return;
        row.style.gridTemplateColumns = widths.map(w => (w > 0 ? w + 'px' : 'auto')).join(' ');
      }

      function syncScroll() {
        const w = wrap();
        const host = headHost();
        if (!w || !host) return;
        const row = host.firstElementChild;
        if (!row) return;
        row.style.transform = `translateX(${-w.scrollLeft}px)`;
      }

      function headerHeight() {
        const host = headHost();
        const row = host?.firstElementChild;
        if (!row) return 0;
        const h = Math.ceil(row.getBoundingClientRect().height);
        return isFinite(h) ? h : 0;
      }

      function filtersOffset() {
        const f = filters();
        if (!f) return 0;
        const rect = f.getBoundingClientRect();
        if (rect.top <= 0) return Math.max(0, Math.ceil(rect.height) - 1);
        return 0;
      }

      function updateMode() {
        const w = wrap();
        const host = headHost();
        const tbl = table();
        if (!w || !host || !tbl) return;
        const wrapRect = w.getBoundingClientRect();
        const tblRect = tbl.getBoundingClientRect();
        const topLimit = filtersOffset();
        const hdrH = headerHeight();

        if (tblRect.top > topLimit) {
          host.classList.remove('is-fixed');
          host.style.position = 'absolute';
          host.style.top = tbl.offsetTop + 'px';
          host.style.left = '0px';
          host.style.right = '0px';
          host.style.width = '';
          return;
        }

        if (tblRect.bottom <= topLimit + hdrH) {
          host.classList.remove('is-fixed');
          host.style.position = 'absolute';
          const bottomTop = tbl.offsetTop + tbl.clientHeight - hdrH;
          host.style.top = bottomTop + 'px';
          host.style.left = '0px';
          host.style.right = '0px';
          host.style.width = '';
          return;
        }

        host.classList.add('is-fixed');
        host.style.position = 'fixed';
        host.style.top = topLimit + 'px';
        host.style.left = Math.round(wrapRect.left) + 'px';
        host.style.width = Math.round(wrapRect.width) + 'px';
      }

      function bind() {
        const w = wrap();
        if (!w) return;
        window.addEventListener('resize', syncWidths);
        w.addEventListener('scroll', syncScroll, { passive: true });
        window.addEventListener('scroll', updateMode, { passive: true });
        window.addEventListener('resize', updateMode);
      }

      return { rebuild, syncWidths, syncScroll, bind, updateMode };
    })();

    // Initialize sticky system on load
    window.addEventListener('load', () => { if (window.stickyApi) { window.stickyApi.bind(); window.stickyApi.rebuild(); window.stickyApi.updateMode(); } });

    // --- Persist and restore state across page switches (single session) ---
    function debounce(fn, wait) {
      let t = null; return function(...args){ clearTimeout(t); t = setTimeout(() => fn.apply(this, args), wait); };
    }

    function restoreMoviesOnLoad() {
      const st = readMoviesState();
      if (!st || !st.filters) return;
      const f = st.filters;
      // Restore inputs
      if (el('title')) el('title').value = f.title || '';
      if (el('genre')) el('genre').value = f.genre || '';
      if (el('director')) el('director').value = f.director || '';
      if (el('actor')) el('actor').value = f.actor || '';
      if (el('oscarsWonDetails')) el('oscarsWonDetails').value = f.oscarsWonDetails || '';
      if (el('studio')) el('studio').value = f.studio || '';
      if (el('minRating')) el('minRating').value = f.minRating || '';
      if (el('yearStart')) el('yearStart').value = f.yearStart || '';
      if (el('yearEnd')) el('yearEnd').value = f.yearEnd || '';
      if (el('sort')) el('sort').value = f.sortDropdown || 'title';
      refreshValueHighlights();

      const hasAnyFilter = Object.entries(f).some(([k,v]) => k !== 'sortDropdown' && v && String(v).trim() !== '');
      // Trigger a fetch if prior filters exist OR we know a search ran previously this session
      if (hasAnyFilter || st.lastSearched) {
        // Trigger a fetch using restored inputs
        const btn = el('btnSearch');
        if (btn && !btn.disabled) btn.click();
        // After results arrive, optionally re-apply column sort and restore scroll
        const start = Date.now();
        const timer = setInterval(() => {
          const ready = Array.isArray(lastResults) && lastResults.length >= 0; // allow 0 results case
          const tablePresent = !!document.getElementById('resultsTable');
          if (ready && tablePresent) {
            clearInterval(timer);
            // Re-apply column sort if any
            if (st.colSort && st.colSort.key && st.colSort.dir) {
              currentSort = { key: st.colSort.key, dir: st.colSort.dir };
              if (Array.isArray(lastResults)) {
                const data = sortData(lastResults, currentSort.key, currentSort.dir);
                renderInto(el('results'), data);
              }
            }
            // Restore horizontal scroll
            const wrap = document.querySelector('#results .table-wrap') || document.querySelector('.table-wrap');
            if (wrap && typeof st.scrollX === 'number') {
              try { wrap.scrollLeft = st.scrollX; } catch (_) {}
            }
            // Restore vertical scroll
            if (typeof st.scrollY === 'number') {
              try { window.scrollTo(0, st.scrollY); } catch (_) {}
            }
            if (window.stickyApi && typeof window.stickyApi.updateMode === 'function') {
              try { window.stickyApi.updateMode(); } catch (_) {}
            }
          } else if (Date.now() - start > 4000) {
            clearInterval(timer);
          }
        }, 120);
      }
    }

    // Save scroll positions while interacting
    const saveScrollDebounced = debounce(() => saveMoviesState(), 200);
    window.addEventListener('scroll', saveScrollDebounced, { passive: true });
    document.addEventListener('DOMContentLoaded', () => {
      const wrap = document.querySelector('#results .table-wrap') || document.querySelector('.table-wrap');
      if (wrap) wrap.addEventListener('scroll', saveScrollDebounced, { passive: true });
      restoreMoviesOnLoad();
    });
    window.addEventListener('beforeunload', () => { saveMoviesState(); });

    // Smoothly scroll so the Results header (with count on the right) is visible directly
    // under the sticky filters, and reset horizontal scroll of the results table.
    function scrollResultsToTop() {
      const wrap = document.querySelector('#results .table-wrap') || document.querySelector('.table-wrap');
      // Prefer the combined Results header (title + KPI) as the anchor so both are visible
      const header = document.getElementById('resultsHeader');
      const kpis = document.getElementById('kpis');
      const anchor = (header || kpis || wrap);
      if (!anchor) return;

      // Reset any horizontal scroll so header/columns start aligned at the left
      if (wrap) {
        try { wrap.scrollLeft = 0; } catch (_) {}
      }

      // If our sticky layout depends on dynamic sizes (e.g., mask width), refresh before measuring
      if (typeof updateStickyHeaderOffset === 'function') {
        try { updateStickyHeaderOffset(); } catch (_) {}
      }

      const filters = document.querySelector('.sticky-filters');
      const anchorTop = anchor.getBoundingClientRect().top + window.pageYOffset;
      let offset = 0;
      if (filters) {
        const fr = filters.getBoundingClientRect();
        // subtract 1px to avoid a visual gap, mirroring header offset logic
        offset = Math.max(0, Math.ceil(fr.height) - 1);
      }
      const target = Math.max(0, Math.round(anchorTop - offset));
      try {
        window.scrollTo({ top: target, behavior: 'smooth' });
      } catch (_) {
        window.scrollTo(0, target);
      }
      // Ensure sticky header recalculates immediately for the new scroll position
      if (window.stickyApi && typeof window.stickyApi.updateMode === 'function') {
        try { window.stickyApi.updateMode(); } catch (_) {}
      }
    }
  </script>
</body>
</html>
