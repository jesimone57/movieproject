<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Actor Filmographies</title>
  <style>
    :root {
      --bg: #f7fafc;
      --card: #ffffff;
      --text: #1f2937;
      --muted: #6b7280;
      --primary: #4a90e2;
      --primary-dark: #3579c8;
      --border: #e5e7eb;
      --chip: #eef2f7;
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color: var(--text);
      background: linear-gradient(180deg, #fbfdff 0%, var(--bg) 100%);
    }

    header { padding: 28px 16px 8px; text-align: center; }
    h1 { margin: 0 0 6px; font-size: 26px; letter-spacing: .2px; }
    .subtitle { color: var(--muted); font-size: 14px; }

    /* Make the layout 50% wider to give more horizontal room,
       which also makes the filmography column effectively 50% wider */
    .container { max-width: 1710px; margin: 0 auto; padding: 16px; }

    .panel {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.04);
    }

    /* Keep the search filters/header section accessible while scrolling */
    .sticky-filters {
      position: sticky;
      top: 0;
      z-index: 30;
    }

    .grid { display: grid; grid-template-columns: repeat(12, 1fr); gap: 12px; align-items: end; }
    label { display: block; font-size: 12px; color: var(--muted); margin-bottom: 6px; }

    input, select { width: 100%; padding: 10px 12px; font-size: 14px; color: var(--text); background: #fff; border: 1px solid var(--border); border-radius: 8px; outline: none; transition: box-shadow .15s ease, border-color .15s ease; }
    input:focus, select:focus { border-color: var(--primary); box-shadow: 0 0 0 3px rgba(74,144,226,0.15); }
    /* Visually mark inputs that participated in the most recent search */
    input.filter-active {
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(74,144,226,0.2);
    }

    .btn { display: inline-flex; align-items: center; gap: 8px; padding: 10px 14px; border: 1px solid var(--primary); background: var(--primary); color: #fff; border-radius: 10px; font-weight: 600; cursor: pointer; transition: background .15s ease, transform .05s ease; text-decoration: none; white-space: nowrap; }
    .btn.secondary { background: #fff; color: var(--primary); }
    .btn:hover { background: var(--primary-dark); }
    .btn.secondary:hover { background: #f5f9ff; }
    .btn:active { transform: translateY(1px); }

    .actions { display: flex; flex-wrap: wrap; gap: 8px; }
    .actions-row { display: flex; justify-content: space-between; align-items: center; gap: 12px; margin-top: 8px; }
    .actions-right { display: flex; align-items: center; gap: 8px; }
    .actions-right label { margin: 0; }
    .actions-right .inline-field { display:flex; flex-direction: column; gap:4px; }
    .actions-right .inline-field input { min-width: 260px; }

    .results { margin-top: 18px; display: grid; grid-template-columns: 1fr; gap: 12px; }
    /* Allow horizontal scroll for wide tables but keep vertical scrolling on the page
       so the sticky filter header can pin to the top of the viewport */
    .table-wrap { position: relative; overflow-x: auto; overflow-y: visible; border: 1px solid var(--border); border-radius: 12px; background: var(--card); }
    /* Use separate border model to avoid Safari sticky bugs */
    table { border-collapse: separate; border-spacing: 0; width: 100%; min-width: 880px; }
    th, td { padding: 8px 10px; border-bottom: 1px solid var(--border); text-align: left; font-size: 14px; }
    /* Disable sticky on native thead; use a cloned sticky header instead. Keep it in layout for width calc */
    thead { position: static; z-index: auto; visibility: hidden; pointer-events: none; }
    thead th { position: static; background: #f1f5f9; font-weight: 700; color: #334155; }

    /* External header that mirrors the table header cells. We'll control its
       positioning purely via JS (fixed/absolute) for crossâ€‘browser reliability. */
    .sticky-head {
      position: absolute; /* default; JS switches to fixed while sticking */
      top: 0;
      left: 0;
      right: 0;
      z-index: 20;
      background: #f1f5f9;
      border-bottom: 1px solid var(--border);
      overflow: hidden; /* allow inner row to translate for horizontal sync */
    }
    .sticky-head.is-fixed { position: fixed; }
    .sticky-head.at-bottom { /* remains absolute; marker class for debugging */ }
    .sticky-head .row {
      display: grid;
      align-items: center;
      grid-auto-rows: minmax(0, auto);
      will-change: transform;
    }
    .sticky-head .cell { 
      padding: 8px 10px; 
      font-weight: 700; 
      color: #334155; 
      border-right: 0; 
      white-space: normal;
      font-size: 14px; /* match table header font size */
    }
    tbody tr:hover { background: #f9fbfd; }
    .numcol { text-align: right; font-variant-numeric: tabular-nums; white-space: nowrap; }
    /* Allow wrapping inside numeric headers so we can split labels across two lines */
    th.numcol { white-space: normal; }

    .sortable { display: inline-flex; align-items: center; gap: 4px; }
    .sort-controls { display: inline-flex; flex-direction: column; gap: 1px; align-items: center; margin-left: 2px; }
    .sort-controls button { padding: 0 3px; line-height: 1; height: 14px; min-width: 16px; border: 1px solid transparent; border-radius: 4px; background: transparent; color: #64748b; cursor: pointer; font-size: 12px; }
    .sort-controls button:hover { background: #e2e8f0; color: #334155; }
    .sort-controls button.active { background: #dbeafe; border-color: #bfdbfe; color: #1d4ed8; font-weight: 700; }

    .note { color: var(--muted); font-size: 12px; }
    .footer { text-align: center; color: var(--muted); font-size: 12px; padding: 18px; }

    /* Column sizing tweaks per updated requirements */
    /* 1: Name, 2: Life (Bornâ€“Died), 3: Career (Firstâ€“Last film), 4: Feature Films (#), 5: Oscars Nominated, 6: Oscars Won, 7: Filmography */
    th:nth-child(1), td:nth-child(1) { min-width: 195px; }
    th:nth-child(2), td:nth-child(2) { width: 80px; }                /* compact life span */
    th:nth-child(3), td:nth-child(3) { width: 80px; }                /* compact career span */
    th:nth-child(4), td:nth-child(4) { width: 60px; }                /* # of feature films */
    th:nth-child(5), td:nth-child(5) { width: 60px; }                /* Small twoâ€‘digit numbers */
    th:nth-child(6), td:nth-child(6) { width: 60px; }                /* Small twoâ€‘digit numbers */
    th:nth-child(7), td:nth-child(7) { width: 73%; }                 /* Keep filmography width unchanged */

    /* Filmography cell: show each film on a separate line with light spacing */
    .film-line + .film-line { margin-top: 4px; }

    /* KPI pill (copied to match index.html look) */
    .kpi {
      display: inline-block;
      padding: 4px 10px;
      border-radius: 999px;
      background: var(--chip);
      font-size: 12px;
    }

    /* Award emphasis */
    .oscar-win { color: #0a7a20; font-weight: 700; }
    .oscar-nom { color: #0b5ed7; font-weight: 700; }
    .hl { background: yellow; }
  </style>
</head>
<body>
  <header>
    <h1>Actor Filmographies</h1>
    <div class="subtitle">Search actors and view their filmography and awards</div>
  </header>

  <main class="container">
    <section class="panel sticky-filters">
      <div class="grid">
        <div style="grid-column: span 4;">
          <label for="name">Actor Name</label>
          <input id="name" type="text" placeholder="e.g., James Stewart" />
        </div>
        <div style="grid-column: span 2;">
          <label for="year">Year</label>
          <input id="year" type="number" inputmode="numeric" placeholder="e.g., 1946" />
        </div>
        <div style="grid-column: span 3;">
          <label for="oscarsNominated">Oscars Nominated</label>
          <input id="oscarsNominated" type="number" inputmode="numeric" placeholder="e.g., 5" />
        </div>
        <div style="grid-column: span 3;">
          <label for="oscarsWon">Oscars Won</label>
          <input id="oscarsWon" type="number" inputmode="numeric" placeholder="e.g., 1" />
        </div>
      </div>
      <div class="actions-row">
        <div class="actions">
          <button id="searchBtn" class="btn" title="Search">ðŸ”Ž Search</button>
          <button id="clearBtn" class="btn secondary" title="Clear filters">âœ– Clear</button>
          <span id="resultCount" class="kpi" style="display:none"></span>
          <!-- Quick switch to Movies view -->
          <span style="align-self:center; color: var(--muted); font-size: 12px;">View</span>
          <a href="index.html" class="btn secondary" id="btnViewMovies" title="Switch to Movies">Movies</a>
        </div>
        <div class="actions-right">
          <div class="inline-field">
            <label for="filmListSearchText">Search filmographies by</label>
            <input id="filmListSearchText" type="text" placeholder="e.g., title, plot, awards, rating" />
          </div>
          <label for="sort">Sort Filmographies By</label>
          <select id="sort">
            <option value="title" selected>Title</option>
            <option value="year">Year</option>
            <option value="rating">Rating</option>
          </select>
        </div>
      </div>
    </section>

    <div class="results">
        <div class="table-wrap">
          <div id="stickyHead" class="sticky-head"></div>
          <table id="resultsTable">
            <colgroup>
              <col style="width: 14%">   <!-- Name -->
              <col style="width: 4%">    <!-- Life (Bornâ€“Died) -->
              <col style="width: 4%">    <!-- Career (Firstâ€“Last film) -->
              <col style="width: 2%">    <!-- # Feature Films -->
              <col style="width: 1%">    <!-- Oscars Nominated (2-digit) -->
              <col style="width: 2%">    <!-- Oscars Won (2-digit) -->
              <col style="width: 73%">   <!-- Filmography (wider, unchanged) -->
            </colgroup>
            <thead>
              <tr>
                <th>
                  <span class="sortable">Name
                    <span class="sort-controls">
                      <button data-col="name" data-dir="asc">â–²</button>
                      <button data-col="name" data-dir="desc">â–¼</button>
                    </span>
                  </span>
                </th>
                <th class="numcol">
                  <span class="sortable">Life
                    <span class="sort-controls">
                      <button data-col="life" data-dir="asc">â–²</button>
                      <button data-col="life" data-dir="desc">â–¼</button>
                    </span>
                  </span>
                </th>
                <th class="numcol">
                  <span class="sortable">Career
                    <span class="sort-controls">
                      <button data-col="career" data-dir="asc">â–²</button>
                      <button data-col="career" data-dir="desc">â–¼</button>
                    </span>
                  </span>
                </th>
                <th class="numcol">
                  <span class="sortable">Feature<br>Films
                    <span class="sort-controls">
                      <button data-col="features" data-dir="asc">â–²</button>
                      <button data-col="features" data-dir="desc">â–¼</button>
                    </span>
                  </span>
                </th>
                <th class="numcol">
                  <span class="sortable">Oscars<br>Nominated
                    <span class="sort-controls">
                      <button data-col="noms" data-dir="asc">â–²</button>
                      <button data-col="noms" data-dir="desc">â–¼</button>
                    </span>
                  </span>
                </th>
                <th class="numcol">
                  <span class="sortable">Oscars<br>Won
                    <span class="sort-controls">
                      <button data-col="won" data-dir="asc">â–²</button>
                      <button data-col="won" data-dir="desc">â–¼</button>
                    </span>
                  </span>
                </th>
                <th>Filmography</th>
              </tr>
            </thead>
            <tbody id="tbody"></tbody>
          </table>
        </div>
        <div id="status" class="note"></div>
      </div>

    <p class="note">Tip: Use the sort arrows in the headers. The Search button requests the server, Clear removes filters and results.</p>
  </main>

  <footer class="footer">Built for ActorFilmographyController â€¢ /api/filmographies/search</footer>

  <script>
    const api = '/api/filmographies/search';
    let data = [];
    let sortState = { col: null, dir: null };

    // ---- UI State Persistence (single-session; store only UI state) ----
    const AF_STATE_KEY = 'ui.af.state';
    const readAfState = () => { try { const raw = sessionStorage.getItem(AF_STATE_KEY); return raw ? JSON.parse(raw) : null; } catch(_) { return null; } };
    const writeAfState = (st) => { try { sessionStorage.setItem(AF_STATE_KEY, JSON.stringify(st)); } catch(_) {} };
    const clearAfState = () => { try { sessionStorage.removeItem(AF_STATE_KEY); } catch(_) {} };
    function collectAfFilters() {
      return {
        name: ($('name')?.value || '').trim(),
        year: ($('year')?.value || '').trim(),
        oscarsNominated: ($('oscarsNominated')?.value || '').trim(),
        oscarsWon: ($('oscarsWon')?.value || '').trim(),
        filmListSearchText: ($('filmListSearchText')?.value || '').trim(),
        sortDropdown: ($('sort')?.value || 'title').trim(),
      };
    }
    function collectAfState(extra={}) {
      const filters = collectAfFilters();
      const colSort = (sortState && sortState.col && sortState.dir) ? { col: sortState.col, dir: sortState.dir } : null;
      const scrollY = window.scrollY || window.pageYOffset || 0;
      const wrap = document.querySelector('.table-wrap');
      const scrollX = wrap ? wrap.scrollLeft : 0;
      return { filters, colSort, scrollY, scrollX, ...extra };
    }
    function saveAfState(extra={}) { writeAfState(collectAfState(extra)); }

    // Helpers
    const $ = (id) => document.getElementById(id);

    function buildQuery() {
      const params = new URLSearchParams();
      const name = $('name').value.trim();
      const year = $('year').value.trim();
      const noms = $('oscarsNominated').value.trim();
      const won = $('oscarsWon').value.trim();
      const filmListSearchText = ($('filmListSearchText')?.value || '').trim();
      const sort = ($('sort')?.value || 'title').trim();
      if (name) params.set('name', name);
      if (year) params.set('year', year);
      if (noms) params.set('oscarsNominated', noms);
      if (won) params.set('oscarsWon', won);
      if (filmListSearchText) params.set('filmListSearchText', filmListSearchText);
      // Always include sort, default to 'title'
      params.set('sort', sort || 'title');
      // Remember current filmography search term for client-side highlighting
      window.currentFilmSearch = filmListSearchText;
      return params.toString() ? api + '?' + params.toString() : api;
    }

    function fmt(val, fallback = '') { return (val ?? '') === '' ? fallback : val; }
    function num(val) { return val == null ? null : Number(val); }

    function escapeHtml(s) {
      return String(s)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    // Highlight Oscar awards inside the perâ€‘film awards text
    // Examples to highlight:
    //  - "Oscar: Win â€“ Best Actor" => bold green (oscar-win)
    //  - "Oscar: Nomination â€“ Best Actor" => bold blue (oscar-nom)
    // Non-Oscar awards remain unstyled.
    function highlightAwards(raw) {
      if (!raw || typeof raw !== 'string') return '';
      // Split on semicolons to preserve each award token
      const tokens = raw.split(';');
      const out = tokens.map((tok) => {
        const t = tok.trim();
        if (t.length === 0) return '';
        const hasOscar = /\boscars?\b/i.test(t);
        if (!hasOscar) {
          return escapeHtml(t);
        }
        const isWin = /\bwin(s)?\b/i.test(t);
        const isNom = /\bnomination|nominated\b/i.test(t);
        const safe = escapeHtml(t);
        if (isWin) return `<span class="oscar-win">${safe}</span>`;
        if (isNom) return `<span class="oscar-nom">${safe}</span>`;
        // If it's an Oscar but neither win nor nomination matched, just return escaped
        return safe;
      });
      // Rejoin with semicolons and spaces, mirroring input style
      return out.join('; ');
    }

    function escapeRegExp(str) {
      return String(str).replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    // Highlight occurrences of term inside an HTML string by simple textual replacement.
    // Assumes the HTML was produced from escaped text (no unsafe input). Case-insensitive.
    function highlightInHtml(html, term) {
      if (!term) return html;
      const pat = new RegExp(escapeRegExp(term), 'gi');
      return html.replace(pat, (m) => `<span class="hl">${m}</span>`);
    }

    function filmToHtml(f) {
      if (!f) return '';
      const title = escapeHtml(fmt(f.title, 'Untitled'));
      const year = (f.year != null) ? ` (${escapeHtml(f.year)})` : '';
      const plot = f.plot ? ` â€” ${escapeHtml(f.plot)}` : '';
      const awards = f.awards ? ` â€” Awards: ${highlightAwards(String(f.awards))}` : '';
      const r = f.ratings || {};
      const parts = [];
      if (typeof r.imdb === 'number') parts.push(`IMDb ${r.imdb.toFixed(1)}`);
      if (r.rottenRomatoesCriticScore) parts.push(`RT Critic ${escapeHtml(r.rottenRomatoesCriticScore)}`);
      if (r.rottenTomatoesPopcornScore) parts.push(`RT Popcorn ${escapeHtml(r.rottenTomatoesPopcornScore)}`);
      const ratings = parts.length ? ` â€” Ratings: ${parts.join(', ')}` : '';
      let html = `<strong>${title}</strong>${year}${plot}${awards}${ratings}`;
      const term = (window.currentFilmSearch || '').trim();
      if (term) {
        html = highlightInHtml(html, term);
      }
      return html;
    }

    function aggregateFilmographyHtml(entry) {
      const films = Array.isArray(entry.filmography) ? entry.filmography : [];
      if (!films.length) return '';
      return films.map(f => `<div class="film-line">${filmToHtml(f)}</div>`).join('');
    }

    // Sort each actor's filmography list in-place by the provided key: 'title' | 'year' | 'rating'
    function sortFilmographiesInPlace(sortKeyRaw) {
      const sortKey = String(sortKeyRaw || 'title').toLowerCase();
      const collator = new Intl.Collator(undefined, { sensitivity: 'base' });

      // Precompute comparators for film entries
      const cmp = {
        title: (a, b) => {
          const ta = (a?.title ?? '').toString();
          const tb = (b?.title ?? '').toString();
          return collator.compare(ta, tb);
        },
        year: (a, b) => {
          const ya = (a?.year ?? null);
          const yb = (b?.year ?? null);
          if (ya == null && yb == null) return 0;
          if (ya == null) return -1; // nulls first (matches backend)
          if (yb == null) return 1;
          return ya - yb; // ascending
        },
        rating: (a, b) => {
          const ra = (a?.ratings && typeof a.ratings.imdb === 'number') ? a.ratings.imdb : -Infinity;
          const rb = (b?.ratings && typeof b.ratings.imdb === 'number') ? b.ratings.imdb : -Infinity;
          if (ra === rb) return 0;
          return rb - ra; // descending
        }
      };

      const comparator = cmp[sortKey] || cmp.title;
      if (!Array.isArray(data)) return;
      for (const entry of data) {
        if (!entry || !Array.isArray(entry.filmography)) continue;
        entry.filmography.sort(comparator);
      }
    }

    function lifeSpan(p) {
      const born = p.year_born ?? p.yearBorn ?? null;
      const died = p.year_died ?? p.yearDied ?? null;
      if (born == null && died == null) return '';
      if (born != null && died == null) return `${born}â€“`;
      if (born == null && died != null) return `â€“${died}`;
      return `${born}â€“${died}`;
    }

    function render() {
      const tbody = $('tbody');
      tbody.innerHTML = '';
      const rows = (data || []);
      for (const it of rows) {
        const p = it.actor_profile || it.actorProfile || {}; // support JSON naming
        const awards = p.actor_awards || p.actorAwards || {};
        const firstFilm = p.year_of_first_film ?? p.yearOfFirstFilm ?? null;
        const lastFilm  = p.year_of_last_film ?? p.yearOfLastFilm ?? null;
        const features  = p.number_of_feature_films_made ?? p.numberOfFeatureFilms ?? null;
        let career = '';
        if (firstFilm != null || lastFilm != null) {
          if (firstFilm != null && lastFilm == null) career = `${firstFilm}â€“`;
          else if (firstFilm == null && lastFilm != null) career = `â€“${lastFilm}`;
          else career = `${firstFilm}â€“${lastFilm}`;
        }
        const tr = document.createElement('tr');
        const cells = [
          fmt(p.name, ''),
          lifeSpan(p),
          career,
          features ?? '',
          awards.oscars_nominated ?? awards.oscarsNominated ?? '',
          awards.oscars_won ?? awards.oscarsWon ?? '',
          aggregateFilmographyHtml(it)
        ];
        cells.forEach((c, idx) => {
          const td = document.createElement('td');
          if (idx === 6) {
            td.innerHTML = c || '';
          } else {
            td.textContent = c === null ? '' : c;
          }
          // numeric/small text alignment for columns 2..6 (all but Name and Filmography)
          if (idx >= 1 && idx <= 5) td.classList.add('numcol');
          // Awards coloring: won -> bold green, else if nominated -> bold blue
          if (idx === 4 || idx === 5) {
            const n = Number(c);
            if (!Number.isNaN(n) && n > 0) {
              if (idx === 5) {
                td.classList.add('oscar-win');
              } else {
                // Only apply nomination color if no wins (wins take precedence visually in adjacent cell)
                td.classList.add('oscar-nom');
              }
            }
          }
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      }
      updateActiveSortButtons();
    }

    function compare(a, b, col) {
      const pA = a.actor_profile || a.actorProfile || {};
      const pB = b.actor_profile || b.actorProfile || {};
      const awA = pA.actor_awards || pA.actorAwards || {};
      const awB = pB.actor_awards || pB.actorAwards || {};
      let va, vb;
      switch (col) {
        case 'name': va = (pA.name || '').toLowerCase(); vb = (pB.name || '').toLowerCase(); break;
        case 'life': va = pA.year_born ?? pA.yearBorn ?? null; vb = pB.year_born ?? pB.yearBorn ?? null; break; // sort by birth year
        case 'career': {
          const fa = pA.year_of_first_film ?? pA.yearOfFirstFilm ?? null;
          const la = pA.year_of_last_film ?? pA.yearOfLastFilm ?? null;
          const fb = pB.year_of_first_film ?? pB.yearOfFirstFilm ?? null;
          const lb = pB.year_of_last_film ?? pB.yearOfLastFilm ?? null;
          // Prefer first film year; if missing, fall back to last film year
          va = fa ?? la ?? null;
          vb = fb ?? lb ?? null;
          break;
        }
        case 'features': va = pA.number_of_feature_films_made ?? pA.numberOfFeatureFilms ?? null; vb = pB.number_of_feature_films_made ?? pB.numberOfFeatureFilms ?? null; break;
        case 'noms': va = awA.oscars_nominated ?? awA.oscarsNominated ?? null; vb = awB.oscars_nominated ?? awB.oscarsNominated ?? null; break;
        case 'won':  va = awA.oscars_won ?? awA.oscarsWon ?? null;       vb = awB.oscars_won ?? awB.oscarsWon ?? null; break;
        default: va = 0; vb = 0;
      }
      const isNum = typeof va === 'number' || typeof vb === 'number';
      if (isNum) { va = num(va); vb = num(vb); }
      if (va == null && vb == null) return 0;
      if (va == null) return -1;
      if (vb == null) return 1;
      if (isNum) return va - vb;
      return va.localeCompare(vb);
    }

    function sortData(col, dir) {
      if (!col || !dir) return;
      sortState = { col, dir };
      data.sort((a, b) => {
        const r = compare(a, b, col);
        return dir === 'asc' ? r : -r;
      });
      render();
      // After sorting, move the viewport to the top of the results so users
      // see the list from the beginning with the new order.
      scrollResultsToTop();
    }

    function updateActiveSortButtons() {
      document.querySelectorAll('.sort-controls button').forEach(btn => {
        const active = sortState.col === btn.dataset.col && sortState.dir === btn.dataset.dir;
        btn.classList.toggle('active', active);
      });
    }

    function setResultCount(n) {
      const rc = $('resultCount');
      if (typeof n === 'number') {
        rc.textContent = `${n} result${n === 1 ? '' : 's'}`;
        rc.style.display = 'inline-block';
      } else {
        rc.textContent = '';
        rc.style.display = 'none';
      }
    }

    // Mark which filter inputs were used in the latest successful search
    function setActiveFilters(usedIds) {
      const all = ['name','year','oscarsNominated','oscarsWon','filmListSearchText'];
      all.forEach(id => {
        const el = $(id);
        if (el) el.classList.toggle('filter-active', Array.isArray(usedIds) && usedIds.includes(id));
      });
    }

    async function search() {
      // Determine which filter inputs are currently non-empty to mark as active upon success
      const used = [];
      if ($('name')?.value.trim()) used.push('name');
      if ($('year')?.value.trim()) used.push('year');
      if ($('oscarsNominated')?.value.trim()) used.push('oscarsNominated');
      if ($('oscarsWon')?.value.trim()) used.push('oscarsWon');
      if ($('filmListSearchText')?.value.trim()) used.push('filmListSearchText');

      const url = buildQuery();
      const status = $('status');
      status.textContent = 'Searchingâ€¦';
      try {
        const res = await fetch(url);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        data = await res.json();
        // Ensure filmography rows reflect the current dropdown immediately
        sortFilmographiesInPlace($('sort')?.value || 'title');
        // If a sort is already selected, re-apply; otherwise default sort by name asc
        if (sortState.col && sortState.dir) {
          sortData(sortState.col, sortState.dir);
        } else {
          sortData('name', 'asc');
        }
        status.textContent = `${data.length} result(s)`;
        setResultCount(data.length);
        // Only after a successful search, update which filters are marked active
        setActiveFilters(used);
        // Persist UI state after a successful search
        saveAfState();
      } catch (e) {
        console.error(e);
        data = [];
        render();
        status.textContent = 'Search failed: ' + e.message;
        setResultCount(null);
      }
    }

    function clearFilters() {
      $('name').value = '';
      $('year').value = '';
      $('oscarsNominated').value = '';
      $('oscarsWon').value = '';
      if ($('filmListSearchText')) $('filmListSearchText').value = '';
      window.currentFilmSearch = '';
      if ($('sort')) $('sort').value = 'title';
      // Clear any active visual markers on inputs
      setActiveFilters([]);
      data = [];
      sortState = { col: null, dir: null };
      $('tbody').innerHTML = '';
      $('status').textContent = '';
      updateActiveSortButtons();
      setResultCount(null);
      // Clear persisted state for AF page
      clearAfState();
      // After clearing, immediately perform the default search to repopulate results
      // Default search = no filters, sort title, and default actor sort by name asc
      search();
    }

    // Events
    document.querySelectorAll('.sort-controls button').forEach(btn => {
      btn.addEventListener('click', () => { sortData(btn.dataset.col, btn.dataset.dir); saveAfState(); });
    });
    $('searchBtn').addEventListener('click', search);
    $('clearBtn').addEventListener('click', clearFilters);

    // Change of filmography sort should immediately re-render without a new fetch
    $('sort').addEventListener('change', () => {
      sortFilmographiesInPlace($('sort').value);
      render();
      saveAfState();
    });

    // Persist inline filmography search typing
    if ($('filmListSearchText')) {
      $('filmListSearchText').addEventListener('input', () => { window.currentFilmSearch = $('filmListSearchText').value.trim(); saveAfState(); });
    }

    // Allow Enter to trigger search
    ['name','year','oscarsNominated','oscarsWon','sort','filmListSearchText'].forEach(id => {
      $(id).addEventListener('keydown', (e) => { if (e.key === 'Enter') search(); });
    });

    // Adjust sticky table header offset to sit below the sticky filters section
    function updateStickyHeaderOffset() {
      const filters = document.querySelector('.sticky-filters');
      const wraps = document.querySelectorAll('.table-wrap');
      let offset = 0;
      if (filters) {
        const rect = filters.getBoundingClientRect();
        // Only offset the table header when the filters bar is actually stuck to the viewport top
        if (rect.top <= 0) {
          // subtract 1px to account for borders and prevent a visible gap
          offset = Math.max(0, Math.ceil(rect.height) - 1);
        }
      }
      wraps.forEach(w => w.style.setProperty('--filters-offset', offset + 'px'));
    }
    window.addEventListener('resize', updateStickyHeaderOffset);
    window.addEventListener('load', updateStickyHeaderOffset);
    window.addEventListener('scroll', updateStickyHeaderOffset, { passive: true });

    // Sticky cloned header implementation (JS-driven fixed/absolute; reliable across Chrome/Safari)
    const stickyApi = (function() {
      const wrap = () => document.querySelector('.table-wrap');
      const headHost = () => document.getElementById('stickyHead');
      const table = () => document.getElementById('resultsTable');
      const theadRow = () => document.querySelector('#resultsTable thead tr');
      const filters = () => document.querySelector('.sticky-filters');

      function rebuild() {
        const host = headHost();
        const tr = theadRow();
        if (!host || !tr) return;

        // Build container
        host.innerHTML = '';
        const row = document.createElement('div');
        row.className = 'row';

        // Clone each header cell into a matching div.cell
        const ths = Array.from(tr.children);
        ths.forEach((th) => {
          const cell = document.createElement('div');
          cell.className = 'cell';
          // preserve inner HTML to keep sort controls/buttons
          cell.innerHTML = th.innerHTML;
          // numeric alignment
          if (th.classList.contains('numcol')) cell.style.textAlign = 'right';
          row.appendChild(cell);
        });
        host.appendChild(row);

        // Wire sort buttons in the cloned header
        host.querySelectorAll('.sort-controls button').forEach(btn => {
          btn.addEventListener('click', () => sortData(btn.dataset.col, btn.dataset.dir));
        });

        // Apply widths now
        syncWidths();
        // Ensure horizontal sync
        syncScroll();
        // Reflect active sort state
        updateActiveSortButtons();
        // Update positioning mode
        updateMode();
      }

      function syncWidths() {
        const tr = theadRow();
        const host = headHost();
        if (!tr || !host) return;
        const ths = Array.from(tr.children);
        const widths = ths.map(th => Math.ceil(th.getBoundingClientRect().width));
        const row = host.firstElementChild;
        if (!row) return;
        // Set grid columns to measured pixel widths to align perfectly
        row.style.gridTemplateColumns = widths.map(w => (w > 0 ? w + 'px' : 'auto')).join(' ');
      }

      function syncScroll() {
        const w = wrap();
        const host = headHost();
        if (!w || !host) return;
        const row = host.firstElementChild;
        if (!row) return;
        // Translate inner row (not the sticky container) to follow horizontal scroll
        row.style.transform = `translateX(${-w.scrollLeft}px)`;
      }

      function headerHeight() {
        const host = headHost();
        const row = host?.firstElementChild;
        if (!row) return 0;
        const h = Math.ceil(row.getBoundingClientRect().height);
        return isFinite(h) ? h : 0;
      }

      function filtersOffset() {
        const f = filters();
        if (!f) return 0;
        const rect = f.getBoundingClientRect();
        if (rect.top <= 0) return Math.max(0, Math.ceil(rect.height) - 1);
        return 0;
      }

      function updateMode() {
        const w = wrap();
        const host = headHost();
        const tbl = table();
        if (!w || !host || !tbl) return;

        const wrapRect = w.getBoundingClientRect();
        const tblRect = tbl.getBoundingClientRect();
        const topLimit = filtersOffset();
        const hdrH = headerHeight();

        // Conditions:
        // 1) Before table reaches filters area: header follows table (absolute at top of table)
        // 2) While table is in view: header fixed under filters
        // 3) After passing bottom: header sticks at table bottom (absolute)

        // Case 1: table top below sticking line
        if (tblRect.top > topLimit) {
          host.classList.remove('is-fixed');
          host.classList.remove('at-bottom');
          host.style.position = 'absolute';
          host.style.top = tbl.offsetTop + 'px';
          host.style.left = '0px';
          host.style.right = '0px';
          host.style.width = '';
          return;
        }

        // Case 3: bottom reached (ensure we don't go past the table)
        if (tblRect.bottom <= topLimit + hdrH) {
          host.classList.remove('is-fixed');
          host.classList.add('at-bottom');
          host.style.position = 'absolute';
          const bottomTop = tbl.offsetTop + tbl.clientHeight - hdrH;
          host.style.top = bottomTop + 'px';
          host.style.left = '0px';
          host.style.right = '0px';
          host.style.width = '';
          return;
        }

        // Case 2: fixed under filters bar
        host.classList.add('is-fixed');
        host.classList.remove('at-bottom');
        host.style.position = 'fixed';
        host.style.top = topLimit + 'px';
        host.style.left = Math.round(wrapRect.left) + 'px';
        host.style.width = Math.round(wrapRect.width) + 'px';
      }

      function bind() {
        const w = wrap();
        if (!w) return;
        // Sync on resize and when horizontally scrolling
        window.addEventListener('resize', syncWidths);
        w.addEventListener('scroll', syncScroll, { passive: true });
        // Update positioning on scroll/resize
        window.addEventListener('scroll', updateMode, { passive: true });
        window.addEventListener('resize', updateMode);
      }

      return { rebuild, syncWidths, syncScroll, bind, updateMode };
    })();

    // If the filters content changes height (e.g., result count appears), update offset after render
    const _render = render;
    render = function() { _render(); updateStickyHeaderOffset(); stickyApi.rebuild(); };

    // Initial bindings
    window.addEventListener('load', () => { stickyApi.bind(); stickyApi.rebuild(); stickyApi.updateMode(); });

    // --- Persist and restore state across page switches (single session) ---
    function debounce(fn, wait) { let t=null; return function(...args){ clearTimeout(t); t=setTimeout(() => fn.apply(this,args), wait); }; }
    function restoreAfOnLoad() {
      const st = readAfState();
      if (!st || !st.filters) return;
      const f = st.filters;
      if ($('name')) $('name').value = f.name || '';
      if ($('year')) $('year').value = f.year || '';
      if ($('oscarsNominated')) $('oscarsNominated').value = f.oscarsNominated || '';
      if ($('oscarsWon')) $('oscarsWon').value = f.oscarsWon || '';
      if ($('filmListSearchText')) $('filmListSearchText').value = f.filmListSearchText || '';
      window.currentFilmSearch = f.filmListSearchText || '';
      if ($('sort')) $('sort').value = f.sortDropdown || 'title';

      const hasAny = Object.entries(f).some(([k,v]) => k !== 'sortDropdown' && v && String(v).trim() !== '');
      if (hasAny) {
        // Trigger fetch
        const btn = $('searchBtn');
        if (btn) btn.click();
        const start = Date.now();
        const timer = setInterval(() => {
          const tablePresent = !!document.getElementById('resultsTable');
          if (Array.isArray(data) && tablePresent) {
            clearInterval(timer);
            // Re-apply column sort
            if (st.colSort && st.colSort.col && st.colSort.dir) {
              sortState = { col: st.colSort.col, dir: st.colSort.dir };
              sortData(sortState.col, sortState.dir);
            }
            // Restore horizontal and vertical scroll
            const wrap = document.querySelector('.table-wrap');
            if (wrap && typeof st.scrollX === 'number') { try { wrap.scrollLeft = st.scrollX; } catch(_) {} }
            if (typeof st.scrollY === 'number') { try { window.scrollTo(0, st.scrollY); } catch(_) {} }
            if (stickyApi && typeof stickyApi.updateMode === 'function') stickyApi.updateMode();
          } else if (Date.now() - start > 4000) {
            clearInterval(timer);
          }
        }, 120);
      }
    }
    const saveScrollDebounced = debounce(() => saveAfState(), 200);
    window.addEventListener('scroll', saveScrollDebounced, { passive: true });
    const wrapNode = document.querySelector('.table-wrap');
    if (wrapNode) wrapNode.addEventListener('scroll', saveScrollDebounced, { passive: true });
    document.addEventListener('DOMContentLoaded', restoreAfOnLoad);
    window.addEventListener('beforeunload', () => { saveAfState(); });

    // Optional: perform an initial load (empty filters fetches all if backend supports it)
    // search();

    // Smoothly scroll the page so the results list starts at the top of the viewport,
    // accounting for the sticky filters height so the (cloned) header sits just below it.
    function scrollResultsToTop() {
      const wrap = document.querySelector('.table-wrap');
      if (!wrap) return;
      const filters = document.querySelector('.sticky-filters');
      const wrapTop = wrap.getBoundingClientRect().top + window.pageYOffset;
      let offset = 0;
      if (filters) {
        const fr = filters.getBoundingClientRect();
        // Use current filters height; subtract 1px to avoid visual gap, mirroring header offset logic
        offset = Math.max(0, Math.ceil(fr.height) - 1);
      }
      const target = Math.max(0, Math.round(wrapTop - offset));
      try {
        window.scrollTo({ top: target, behavior: 'smooth' });
      } catch (_) {
        window.scrollTo(0, target);
      }
      // Ensure sticky header recalculates immediately for the new scroll position
      if (stickyApi && typeof stickyApi.updateMode === 'function') {
        stickyApi.updateMode();
      }
    }
  </script>
</body>
</html>
